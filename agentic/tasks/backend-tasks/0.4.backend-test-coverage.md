# 0.4 Backend Test Coverage

> ✅ CLOSED — superseded by 0.5 and post-review audit in 0.5.1.

## Applicable Instruction Files

Per the [routing table](../../instructions.md), load for every backend task:

| File | Reason |
|------|--------|
| [`backend/service-rules.md`](../../instructions/backend/service-rules.md) | Makefile orchestration, API behaviour, privacy |
| [`backend/verification.md`](../../instructions/backend/verification.md) | Build gates, deterministic tool matrix, manual review rules, task plan requirements |
| [`backend/code-review-checklist.md`](../../instructions/backend/code-review-checklist.md) | Recurring defect patterns, review protocol |
| [`language-standards.md`](../../instructions/language-standards.md) | TS required rules (arrow fns, no `any`, percentile correctness, semantic naming, transaction writes, no dead exports, no blind casts, shared schemas) |
| [`verification-and-agent-roe.md`](../../instructions/verification-and-agent-roe.md) | Tool-calling conventions, Make target naming, Do/Don't |

## Problem Statement

The backend has integration tests for Phase 2 rollup/metrics features but lacks systematic coverage for Phase 0–1 core services (event ingestion, lead capture, consent management, identity linking, visitor/session lifecycle). Tests that do exist are ad hoc and miss edge cases identified in past code reviews. A structured test suite is needed before the first production deploy.

## Workflow Principles

- **Test against a real database**: Use a Docker Compose test database, not mocks. The `pg` driver + parameterized SQL must hit real Postgres to validate query correctness.
- **Isolated test database**: Each test run gets a fresh schema (via `prisma migrate deploy` or raw SQL init). Tests must not depend on each other's state.
- **Existing pattern**: Follow the test structure established in `backend/test/` for Phase 2 tests (Node.js native test runner via `tsx --test` + Fastify `inject()`).
- **Focus on boundaries**: Test route-level request/response contracts. Unit-test pure utility functions. Service-layer tests are integration tests (they hit the DB).

## Terminology

- **Integration test**: Tests the full route → service → DB path using `app.inject()`.
- **Smoke test**: Minimal test that verifies an endpoint is reachable and returns the expected shape.
- **Edge case**: Inputs that test boundary conditions (empty strings, duplicate emails, concurrent requests, honeypot fields).

## Current State Analysis

### Existing test coverage

| Area | Tests | Coverage |
|------|-------|----------|
| Metrics summary route | ✅ | Auth, contract, empty window |
| Rollup engine | ✅ | Idempotent upsert, recompute, multi-day, UTC boundary |
| Schema validation | ✅ | Parse, coercion, rejection |
| Event ingestion | ❌ | No tests |
| Lead capture | ❌ | No tests |
| Consent management | ❌ | No tests |
| Identity linking | ❌ | No tests |
| Visitor/session lifecycle | ❌ | No tests |
| Delete-by-email | ❌ | No tests |
| Unsubscribe | ❌ | No tests |
| Health check | ❌ | No tests |
| Error handling (app-level) | ❌ | No tests |
| Rate limiting | ❌ | No tests |
| Utility functions (`db.ts`, `sql.ts`, `json.ts`) | ❌ | No tests |

### Test infrastructure

- **Runner**: Node.js native test runner via `tsx --test --test-concurrency=1` (configured in `package.json`)
- **Assertions**: `node:assert/strict`
- **HTTP**: Fastify `inject()` (already used in metrics tests)
- **Database**: Local Postgres via Homebrew (Makefile manages lifecycle)
- **Setup/teardown**: Per-suite DB reset via `test/helpers/db.ts`

## Proposed Solution

Implement tests in priority order, grouped by the risk each area poses to a production deploy.

## Patterns to Follow

### Route integration test pattern

```typescript
import assert from "node:assert/strict";
import { after, before, beforeEach, test } from "node:test";
import { buildApp } from "../src/app.js";
import { closeDatabase, resetDatabase } from "./helpers/db.js";

const app = await buildApp();

before(async () => { await resetDatabase(); });
beforeEach(async () => { await resetDatabase(); });
after(async () => { await closeDatabase(); await app.close(); });

test("POST /v1/events accepts a valid event payload", async () => {
  const res = await app.inject({
    method: "POST",
    url: "/v1/events",
    payload: { /* valid payload */ },
  });
  assert.equal(res.statusCode, 202);
  assert.deepStrictEqual(res.json(), { ok: true });
});
```

### DB reset pattern

```typescript
import { pool } from "../src/lib/db.js";

const resetDb = async () => {
  const client = await pool.connect();
  try {
    await client.query("BEGIN");
    await client.query("TRUNCATE visitors, sessions, events, leads, lead_identities, form_submissions, consent_events, ingest_rejections CASCADE");
    await client.query("COMMIT");
  } finally {
    client.release();
  }
};
```

## Agent Do / Don't (This Task)

### Do

- Use `app.inject()` for all route tests (no real HTTP server needed).
- Reset the test database between test suites (not between individual tests, for speed).
- Test both happy path and error paths (400, 401, 429).
- Test the honeypot rejection path (silent 202, no DB write).
- Verify CORS headers in at least one test.

### Do Not

- Mock the database — use real Postgres.
- Write tests that depend on execution order across files.
- Test things already covered by `make -C backend audit` (types, lint, format).
- Add test dependencies beyond what the Node.js native test runner provides (no Vitest, no Supertest, no Jest).

## Manual Review Checklist

- [ ] All SQL queries in services are exercised by at least one integration test.
- [ ] Honeypot path tested: event with honeypot field → 202 response, zero rows in DB.
- [ ] Delete-by-email tested: PII in `form_submissions.payload` is scrubbed or cascade-deleted.
- [ ] Transaction rollback tested: error mid-transaction → no partial writes.

---

# Consolidated Checklist

## Completed

- [x] Audit existing test coverage.
- [x] Define test plan structure.

## Phase 0: Test Infrastructure

- [x] Ensure `docker-compose.test.yml` (or equivalent) starts a clean Postgres for tests.
- [x] Create `test/helpers/db-reset.ts` with table truncation helper.
- [x] Create `test/helpers/fixtures.ts` with factory functions for valid payloads (event, lead, consent).
- [x] Verify `make -C backend test` runs `tsx --test` with test DB connection.
- [x] **Gate**: `make -C backend test` runs (even if no new tests yet).

## Phase 1: Core Route Tests (P0 — Deploy Blockers)

- [x] `test/health.test.ts` — `GET /v1/healthz` returns `{ ok: true }`.
- [x] `test/events.test.ts`:
  - [x] Valid event → 202, row persisted.
  - [x] Invalid payload (missing required fields) → 400.
  - [x] Honeypot field present → 202, no DB write.
  - [x] Rate limit exceeded → 429.
- [x] `test/leads.test.ts`:
  - [x] Valid lead capture → 200, lead + identity + form submission persisted.
  - [x] Duplicate email → upsert (no duplicate rows).
  - [x] Invalid email → 400.
  - [x] Honeypot field → 202 (or appropriate status), no DB write.
- [x] `test/leads-delete.test.ts`:
  - [x] Admin auth required → 401 without key.
  - [x] Valid delete → lead + cascade data removed.
  - [x] Form submission payload scrubbed/deleted.
  - [x] Nonexistent email → 404 or appropriate response.
- [x] `test/leads-unsubscribe.test.ts`:
  - [x] Valid unsubscribe → consent status set to `withdrawn`.
  - [x] Consent event logged.
- [x] **Gate**: `make -C backend test` passes.

## Phase 2: Service-Layer Edge Cases (P1)

- [x] `test/services/visitors.test.ts`:
  - [x] New visitor created on first event.
  - [x] Session timeout triggers new session (>30 min gap).
  - [x] UTM change triggers new session.
- [x] `test/services/consent.test.ts`:
  - [x] Status transitions: pending → express → withdrawn.
  - [x] Invalid transitions rejected or handled gracefully.
  - [x] Consent event created on each transition.
- [x] `test/services/identity.test.ts`:
  - [x] `form_submit` link created at confidence 1.0.
  - [x] Heuristic link created when enabled (`ENABLE_HEURISTIC_LINKING=true`).
  - [x] No heuristic link when disabled.
- [ ] **Gate**: `make -C backend test` passes.

## Phase 3: Utility and Error Handling Tests (P2)

- [x] `test/lib/db.test.ts`:
  - [x] `sql` tag produces correct `$N` parameterized query.
  - [x] `transaction()` commits on success.
  - [x] `transaction()` rolls back on error.
  - [x] Client released after transaction (no pool leak).
- [x] `test/lib/sql.test.ts`:
  - [x] `quoteIdentifier()` escapes special characters.
  - [x] Schema-qualified table references produce valid SQL.
- [x] `test/error-handling.test.ts`:
  - [x] Zod validation error → 400 with structured issues array.
  - [x] Unknown error → 500 with `internal_error`.
  - [x] CORS preflight → correct `Access-Control-Allow-Origin`.
- [x] **Gate**: `make -C backend test` passes.
- [x] **Gate**: `make -C backend audit` passes.

## Stretch Goals

- [ ] Coverage reporting: add `tsx --test --experimental-test-coverage` and track % per module.
- [ ] Concurrent request tests (race conditions on upserts).
- [ ] Load test script using `autocannon` for basic throughput baseline.
- [ ] CI integration: `make -C backend test` in GitHub Actions.

## Success Criteria

- [x] `make -C backend test` passes with all Phase 0–2 tests green.
- [x] `make -C backend audit` passes.
- [x] Event ingestion, lead capture, and delete-by-email each have ≥3 test cases.
- [x] `transaction()` rollback is explicitly tested.
- [x] No test depends on execution order of other test files.
