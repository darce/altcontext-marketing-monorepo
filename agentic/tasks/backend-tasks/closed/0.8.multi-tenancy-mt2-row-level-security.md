# 0.8 Multi-Tenancy MT-2: Row-Level Security

> Enable PostgreSQL Row-Level Security on all tenant-scoped tables, create a restricted `app_user` role, and migrate route handlers to `withTenant`.
> This is Phase MT-2 of the [multi-tenancy epic](../../roadmaps/epics/multi-tenancy-rls.md).
>
> Pre-requisites: Tenant model + API keys (MT-1 / 0.7 ✅).
> Dashboard auth (MT-3) is a separate follow-on task.

## Closure Consolidation (2026-02-17)

MT-2 is closed. Remaining unchecked items in this file were operational follow-ups
(production deploy verification and stretch monitoring). They are now tracked in
the active PG18 consolidation plan:

- `0.8.2.pg18-upgrade-migration.md` (active implementation plan)
- `0.8.3.pg18-index-audit.md` (reference-only; merged into 0.8.2 for greenfield)

## Applicable Instruction Files

Standard backend files per the [routing table](../../instructions.md#backend-tasks).

| File | Load when… |
|------|------------|
| [`available-tools.md`](../../instructions/available-tools.md) | Deployment, migration, or infrastructure commands |
| [`context-and-architecture.md`](../../instructions/context-and-architecture.md) | Understanding multi-workspace relationships |
| [`backend/service-rules.md`](../../instructions/backend/service-rules.md) | Service layer patterns (`pool → transaction → query`) |
| [`backend/verification.md`](../../instructions/backend/verification.md) | Test and audit gates |

## Problem Statement

MT-1 added `tenant_id` to all tables and the `withTenant` transaction wrapper, but the application still connects as `postgres` (table owner, bypasses RLS) and route handlers use bare `transaction()` instead of `withTenant()`. No RLS policies exist. A cross-tenant data leak is prevented only by application-level WHERE clauses — there is no database-level enforcement. MT-2 creates the `app_user` role, enables RLS on all tenant-scoped tables, migrates route handlers to `withTenant`, and verifies that queries without tenant context return zero rows.

## Workflow Principles

- **Dual-role connection model**: The app connects as the table owner for migrations, then `SET ROLE app_user` per-connection for all runtime queries. This avoids managing two separate connection strings on Fly.io while ensuring RLS enforcement.
- **`withTenant` is the only path**: After MT-2, every route handler must use `withTenant()` instead of `transaction()`. Direct `pool` usage in service code is only for tenant-resolution (API key lookup) which queries `api_keys` — a table where RLS is scoped to the `app_user` role.
- **Scripts run as table owner**: `purge-retention.ts`, `rollups-run.ts`, `rollups-backfill.ts` intentionally bypass RLS since they operate cross-tenant or with explicit tenant scoping. They continue using `pool` directly (which connects as the owner role before `SET ROLE`).
- **Non-breaking rollout**: The migration enables RLS and creates the role. The code change switches to `SET ROLE app_user` and `withTenant`. Both changes must land together — the migration alone would not break anything (RLS without `app_user` role in use is a no-op for the table owner), but the code change without the migration would fail.

## Terminology

- **`app_user`**: A non-login PostgreSQL role granted DML (SELECT/INSERT/UPDATE/DELETE) but not table ownership. RLS policies are enforced for this role.
- **Table owner**: The role that owns the tables (currently `postgres` locally, the provisioned role on Fly). Table owners bypass RLS by default.
- **`SET ROLE`**: A session-level command that switches the effective role for subsequent queries. Used in the pool `connect` callback to switch from owner → `app_user`.
- **`SET LOCAL`**: A transaction-scoped command. `SET LOCAL app.current_tenant_id` is already implemented in `withTenant()` — it's what RLS policies read.

## Current State Analysis

### What's in place (from MT-1)

- `tenant_id UUID NOT NULL` on all 12 tenant-scoped tables, with FK to `tenants(id)` and indexes.
- `withTenant(tenantId, fn)` defined in `src/lib/db.ts` — executes `SET LOCAL app.current_tenant_id = $1` within a transaction.
- `tenantResolutionHook` in `src/lib/tenant-resolution.ts` — resolves `request.tenantId` from `x-api-key` or `BOOTSTRAP_TENANT_ID` fallback.
- All service functions accept `tenantId` and include `tenant_id` in WHERE clauses.

### What's missing

- **`withTenant` is never called.** Routes use `transaction()` (no `SET LOCAL`). The `withTenant` wrapper was defined in MT-1 but adoption was incomplete.
- **No `app_user` role.** The app connects as `postgres` (superuser).
- **No RLS policies.** No `ALTER TABLE ... ENABLE ROW LEVEL SECURITY` or `CREATE POLICY` statements exist.
- **`api-keys.ts` uses `pool` directly** — `resolveApiKey()` and `createApiKey()` query outside any transaction. Under RLS, `api_keys` lookups must either bypass RLS (run as owner) or have a permissive policy.
- **`seed-baseline.ts` test helper** is stale — inserts without `tenant_id`.

### Connection model

- **Local dev**: `postgresql://daniel@localhost:5432/altcontext_dev` (user's macOS username = superuser).
- **Tests**: `postgresql://daniel@localhost:5432/altcontext_dev?schema=backend_test` — same role.
- **Fly.io**: `DATABASE_URL` set as a Fly secret — provisioned role with ownership of the database.

## Proposed Solution

### 1. Migration: Create role + enable RLS + create policies

A single migration file that:

1. Creates the `app_user` role (idempotent `DO $$ ... IF NOT EXISTS`).
2. Grants DML on all existing tables to `app_user`.
3. Grants USAGE on all sequences to `app_user`.
4. Enables RLS on all 12 tenant-scoped tables.
5. Creates a `tenant_isolation` policy on each table:
   ```sql
   CREATE POLICY tenant_isolation ON <table>
     FOR ALL
     TO app_user
     USING (tenant_id = current_setting('app.current_tenant_id')::uuid)
     WITH CHECK (tenant_id = current_setting('app.current_tenant_id')::uuid);
   ```
6. Does NOT enable RLS on `tenants` (the owner table — no tenant scoping needed).

### 2. Pool connection hook: `SET ROLE app_user`

Modify `src/lib/db.ts` to set the role after each connection is acquired from the pool. Two approaches:

**Option A — Pool `connect` event** (preferred):
```typescript
pool.on("connect", (client) => {
  client.query("SET ROLE app_user");
});
```

**Option B — Wrapper around `pool.connect()`**:
Override or wrap the pool to issue `SET ROLE` after each `connect()`. More explicit but more invasive.

Option A is simpler and covers all code paths that use the pool.

### 3. Route handler migration: `transaction()` → `withTenant()`

Replace all `transaction(fn)` calls in route handlers with `withTenant(request.tenantId, fn)`:

- `src/routes/events.ts` — `transaction(...)` → `withTenant(request.tenantId, ...)`
- `src/routes/leads.ts` — three `transaction(...)` calls → `withTenant(...)`
- `src/routes/metrics.ts` — `transaction(...)` → `withTenant(request.tenantId, ...)`

### 4. API key service: tenant-resolution bypass

`resolveApiKey()` runs before tenant context is known (it's how we determine the tenant). Two options:

**Option A — Owner-role connection** (preferred): `resolveApiKey` and `createApiKey` continue using `pool` directly. Since the pool now does `SET ROLE app_user`, we need a separate "owner" pool or `RESET ROLE` for these queries.

**Option B — Permissive policy on `api_keys`**: Add a policy that allows `app_user` to SELECT `api_keys` without tenant context. This is safe because `resolveApiKey` only reads by `key_prefix` and returns `tenant_id` — no tenant-scoped data is exposed.

Preferred: **Option B** — add a `SELECT`-only permissive policy on `api_keys` for `app_user` (reads allowed without tenant context; writes still require tenant context). This keeps the single-pool model and avoids maintaining a second connection.

```sql
-- Allow api key lookups without tenant context (for tenant resolution)
CREATE POLICY api_key_lookup ON api_keys
  FOR SELECT
  TO app_user
  USING (true);

-- Restrict writes to tenant context
CREATE POLICY api_key_tenant_write ON api_keys
  FOR INSERT
  TO app_user
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id')::uuid);

CREATE POLICY api_key_tenant_update ON api_keys
  FOR UPDATE
  TO app_user
  USING (tenant_id = current_setting('app.current_tenant_id')::uuid)
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id')::uuid);

CREATE POLICY api_key_tenant_delete ON api_keys
  FOR DELETE
  TO app_user
  USING (tenant_id = current_setting('app.current_tenant_id')::uuid);
```

### 5. Script handling

Scripts (`purge-retention.ts`, `rollups-run.ts`, `rollups-backfill.ts`, `rollups-mv-*.ts`) need to run as the table owner. Options:

- **`RESET ROLE`** at the start of each script before any queries (reverting to the owner role).
- Expose a `withOwnerRole(fn)` helper from `db.ts` that does `RESET ROLE` → fn → `SET ROLE app_user`.

These scripts are CLI tools, not request handlers — they don't need RLS scoping.

### 6. Test infrastructure

- **Test setup/teardown** (`resetDatabase`) uses Prisma, which uses its own connection — it connects as the owner role (not through the app pool), so RLS is bypassed during setup.
- **Integration tests** use `app.inject()` which goes through the Fastify handlers → pool → `SET ROLE app_user` → `withTenant` → RLS-enforced queries. This is the correct behavior.
- **`seed-baseline.ts`** needs `tenant_id` added to all INSERT statements — or it should be refactored to use the app's service functions.
- Add a dedicated RLS isolation test: insert data for two tenants, then verify that a query with tenant A's context cannot see tenant B's data.

## Patterns to Follow

### RLS policy per table

```sql
ALTER TABLE <table> ENABLE ROW LEVEL SECURITY;
CREATE POLICY tenant_isolation ON <table>
  FOR ALL
  TO app_user
  USING (tenant_id = current_setting('app.current_tenant_id')::uuid)
  WITH CHECK (tenant_id = current_setting('app.current_tenant_id')::uuid);
```

### Pool SET ROLE hook

```typescript
pool.on("connect", (client: pg.PoolClient) => {
  // Switch to restricted role — RLS policies enforced from here
  client.query("SET ROLE app_user");
});
```

### Route handler pattern (after migration)

```typescript
// Before (MT-1):
app.post("/v1/events", async (request, reply) => {
  const result = await transaction((tx) =>
    ingestEvent(tx, request.tenantId, body, ctx),
  );
  return reply.code(202).send(result);
});

// After (MT-2):
app.post("/v1/events", async (request, reply) => {
  const result = await withTenant(request.tenantId, (tx) =>
    ingestEvent(tx, request.tenantId, body, ctx),
  );
  return reply.code(202).send(result);
});
```

### Script owner-role pattern

```typescript
// In scripts that need cross-tenant access:
const client = await pool.connect();
try {
  await client.query("RESET ROLE"); // Revert to table owner — bypass RLS
  // ... run cross-tenant queries ...
} finally {
  client.release();
}
```

## Functions to Change

| File | Change |
|------|--------|
| `prisma/migrations/<timestamp>_mt2_row_level_security/` | New migration: create `app_user` role, enable RLS, create policies |
| `src/lib/db.ts` | Add `pool.on("connect", ...)` to SET ROLE; export `withOwnerRole` helper for scripts |
| `src/routes/events.ts` | Replace `transaction()` with `withTenant(request.tenantId, ...)` |
| `src/routes/leads.ts` | Replace all `transaction()` calls with `withTenant(request.tenantId, ...)` |
| `src/routes/metrics.ts` | Replace `transaction()` with `withTenant(request.tenantId, ...)` |
| `src/services/api-keys.ts` | No change needed if using permissive SELECT policy on `api_keys` |
| `src/scripts/purge-retention.ts` | Add `RESET ROLE` before cross-tenant queries |
| `src/scripts/rollups-run.ts` | Add `RESET ROLE` before tenant-specific queries |
| `src/scripts/rollups-backfill.ts` | Add `RESET ROLE` before tenant-specific queries |
| `src/scripts/rollups-mv-init.ts` | Add `RESET ROLE` — DDL requires owner role |
| `src/scripts/rollups-mv-refresh.ts` | Add `RESET ROLE` — refresh requires owner role |
| `test/helpers/seed-baseline.ts` | Add `tenant_id` to all INSERT statements |
| `prisma/schema.prisma` | No change needed (schema already has tenant_id on all models) |

## Related Files

| File | Note |
|------|------|
| `agentic/roadmaps/epics/multi-tenancy-rls.md` | Canonical design: RLS strategy §5, connection flow, safety rules |
| `backend/src/lib/tenant-resolution.ts` | Resolves `request.tenantId` — upstream of `withTenant` |
| `backend/src/config/env.ts` | May need new env var if dual-pool approach chosen |
| `backend/test/helpers/db.ts` | Test tenant seeding — uses Prisma (owner role, bypasses RLS) |
| `backend/test/helpers/prisma.ts` | Standalone Prisma client for test setup |

## Agent Do / Don't (This Task)

### Do

- Use idempotent `DO $$ BEGIN IF NOT EXISTS ... END $$` for `CREATE ROLE` in the migration (role may already exist in some environments).
- Grant DML to `app_user` on ALL tables (including `tenants`) — the RLS policies control what's visible, not the grants.
- Grant USAGE + SELECT on all sequences to `app_user` (needed for `gen_random_uuid()` / `DEFAULT` values).
- Test RLS isolation explicitly: insert data for two tenants, verify cross-tenant invisibility.
- Keep `purge-retention.ts` cross-tenant — it's a global maintenance operation.
- Run `make -C backend test` after each phase.

### Do Not

- Create a second `DATABASE_URL` / separate connection pool — use `SET ROLE` on the existing pool.
- Enable RLS on the `tenants` table itself — it's the root table, queried during key resolution.
- Remove application-level `WHERE tenant_id = $tenantId` clauses from services — defense in depth. RLS is the enforcement layer; app-level filtering is a safety net.
- Modify the `withTenant` function signature — it's already correct from MT-1.
- Change the Fly.io `DATABASE_URL` secret — the existing owner role is needed for `SET ROLE`.

## Manual Review Checklist

- [x] `app_user` role exists and has DML grants on all tables.
- [x] RLS enabled on all 12 tenant-scoped tables (not on `tenants`).
- [x] Each policy uses `current_setting('app.current_tenant_id')::uuid` — not a hardcoded UUID.
- [x] `api_keys` has a permissive SELECT policy (tenant resolution runs before context is set).
- [x] `api_keys` write policies require tenant context.
- [x] `pool.on("connect")` issues `SET ROLE app_user`.
- [x] All route handlers use `withTenant()` — no bare `transaction()` calls remain in routes.
- [x] Scripts use `RESET ROLE` before their queries. (All 7 — remaining 2 fixed in 0.8.1)
- [x] RLS isolation test: tenant A cannot see tenant B's data via the app pool.
- [x] No `current_setting` error when `app.current_tenant_id` is not set (test the failure mode).

---

# Consolidated Checklist

## Completed

- [x] Tenant model + API keys (MT-1 / 0.7).
- [x] MT-1 verification — all findings addressed (0.7.1).

## Phase 0: Migration — RLS + Role

- [x] Create migration file `prisma/migrations/<timestamp>_mt2_row_level_security/migration.sql`.
- [x] `CREATE ROLE app_user NOLOGIN` (idempotent).
- [x] `GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_user`.
- [x] `GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO app_user`.
- [x] `ALTER DEFAULT PRIVILEGES ... GRANT` for future tables/sequences.
- [x] `ALTER TABLE ... ENABLE ROW LEVEL SECURITY` on all 12 tenant-scoped tables.
- [x] `CREATE POLICY tenant_isolation` on each of the 12 tables.
- [x] `CREATE POLICY api_key_lookup` (permissive SELECT) on `api_keys`.
- [x] `CREATE POLICY api_key_tenant_write/update/delete` on `api_keys`.
- [x] **Gate**: Migration applies cleanly on dev and test databases.

## Phase 1: Connection + Route Migration

- [x] Add `pool.on("connect", ...)` → `SET ROLE app_user` in `src/lib/db.ts`.
- [x] Replace `transaction()` → `withTenant(request.tenantId, ...)` in `src/routes/events.ts`.
- [x] Replace `transaction()` → `withTenant(request.tenantId, ...)` in `src/routes/leads.ts` (3 calls).
- [x] Replace `transaction()` → `withTenant(request.tenantId, ...)` in `src/routes/metrics.ts`.
- [x] Verify `transaction()` export can be removed or marked deprecated.
- [x] **Gate**: `make -C backend test` — all existing tests pass.

## Phase 2: Scripts + Edge Cases

- [x] Add `RESET ROLE` to `src/scripts/purge-retention.ts`.
- [x] Add `RESET ROLE` to `src/scripts/rollups-run.ts`.
- [x] Add `RESET ROLE` to `src/scripts/rollups-backfill.ts`.
- [x] Add `RESET ROLE` to `src/scripts/rollups-mv-init.ts`.
- [x] Add `RESET ROLE` to `src/scripts/rollups-mv-refresh.ts`.
- [x] Export `withOwnerRole(fn)` from `src/lib/db.ts` if shared pattern emerges.
- [x] Fix `test/helpers/seed-baseline.ts` — add `tenant_id` to all INSERTs.
- [x] Fix `src/scripts/rollups-discrepancy.ts` — uses raw `pool.connect()`, broken under RLS. → **fixed in 0.8.1**
- [x] Fix `src/scripts/rollups-status.ts` — uses raw `pool.connect()`, broken under RLS. → **fixed in 0.8.1**
- [x] Fix `src/services/api-keys.ts` `createApiKey()` — uses module-level `pool` as `app_user` without tenant context, INSERT rejected by RLS write policy. → **fixed in 0.8.1**
- [x] **Gate**: `make -C backend test` — pass.

## Phase 3: RLS Isolation Tests

- [x] Add integration test: two tenants with separate data, verify cross-tenant isolation.
- [x] Add test: query without `SET LOCAL app.current_tenant_id` returns error or zero rows.
- [x] Add test: `resolveApiKey()` works without tenant context (permissive SELECT policy).
- [x] Add test: `createApiKey()` requires tenant context. → **fixed in 0.8.1** (depends on `createApiKey` fix)
- [x] Expand RLS isolation test to cover ≥3 table families (currently only `visitors`). → **fixed in 0.8.1**
- [x] **Gate**: `make -C backend test` — full pass.
- [x] **Gate**: `make -C backend audit` — full pass.

## Phase 4: Deploy & Verify

- [x] Consolidated into 0.8.2 execution plan (greenfield rollout; no production safety track required).

## Stretch Goals

- [x] Consolidated into PG18 planning notes (0.8.2/0.8.3) as optional post-baseline work.

## Success Criteria

- [x] `make -C backend audit` passes.
- [x] `make -C backend test` passes — all integration tests green.
- [x] `app_user` role exists with DML grants, no table ownership.
- [x] RLS enabled on all 12 tenant-scoped tables with `tenant_isolation` policies.
- [x] All route handlers use `withTenant()` — `SET LOCAL app.current_tenant_id` set in every request transaction.
- [x] Queries without tenant context return zero rows (RLS enforced).
- [x] `resolveApiKey()` continues working (permissive SELECT on `api_keys`).
- [x] Scripts bypass RLS via `RESET ROLE` and operate correctly. (All 7 — remaining 2 fixed in 0.8.1)
- [x] Cross-tenant isolation verified by dedicated integration test.

> All gaps from code review resolved in [0.8.1](./0.8.1.mt2-review-findings.md).
