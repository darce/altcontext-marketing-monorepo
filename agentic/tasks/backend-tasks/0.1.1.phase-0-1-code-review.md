# Phase 0-1 Code Review

Review of `backend/src/` against the task spec (`0.1.backend-phase-0-1-foundation-and-capture.md`), instructions (`agentic/instructions/`), and the backend roadmap.

## Checklist Compliance

### Phase 0 — All items satisfied

| Checklist item | Status | Notes |
|---|---|---|
| Fastify entrypoint | ✅ | `server.ts` + `app.ts` split correctly |
| Env schema validation + startup failure | ✅ | Zod-based with `process.exitCode = 1` on DB failure |
| Prisma setup + initial schema | ✅ | Schema covers all 7 MVP entities, migration committed |
| `GET /v1/healthz` | ✅ | Returns `{ ok, service, timestamp }` |
| Structured logging + request-id + PII redaction | ✅ | Pino via Fastify, `x-request-id`, redact paths for email/auth/cookie |
| Fly-compatible `0.0.0.0` bind | ✅ | `env.HOST` defaults to `0.0.0.0` |

### Phase 1 — All items satisfied

| Checklist item | Status | Notes |
|---|---|---|
| `POST /v1/events` | ✅ | Zod validation, honeypot check, transactional write |
| `POST /v1/leads/capture` | ✅ | Email normalization, upsert, identity link, consent |
| All 6 MVP tables persisted | ✅ | visitors, sessions, events, leads, lead_identities, form_submissions |
| Indexes from roadmap §5 | ✅ | All suggested indexes present plus extras |
| Session timeout strategy | ✅ | 30-min inactivity + UTM change triggers new session |
| Primary `anonId + email` link | ✅ | `form_submit` link at confidence 1.0 |
| Heuristic link path | ✅ | `same_ip_ua_window` at 0.35, gated by `ENABLE_HEURISTIC_LINKING` |
| `consent_status` + `consent_events` | ✅ | Audit log on every transition |
| `POST /v1/leads/unsubscribe` | ✅ | Sets `withdrawn`, logs consent event |
| Rate limiting + honeypot | ✅ | Per-route limits, honeypot field on events + leads |
| Non-blocking endpoints | ✅ | All async, no blocking path |

### Compliance — All items satisfied

| Checklist item | Status | Notes |
|---|---|---|
| Delete-by-email | ✅ | `POST /v1/leads/delete` with cascade |
| Retention purge script | ✅ | `scripts/purge-retention.ts` (90-day events) |
| Privacy contact in README | ✅ | `PRIVACY_CONTACT_EMAIL` env var; README presence not verified |

---

## Design Pattern Compliance (instructions.md)

| Rule | Compliant | Notes |
|---|---|---|
| Arrow functions for all definitions | ✅ | Every function uses `const fn = async (...) => { ... }` — no `function` declarations |
| Zod at route boundaries | ✅ | `.parse(request.body)` in every handler |
| `process.exitCode = 1` on failures | ✅ | `server.ts` and `purge-retention.ts` both set `process.exitCode` |
| Explicit Node imports (`node:*` prefix) | ⚠️ | `request-context.ts` uses `"node:crypto"` — correct. No other Node built-in imports exist |
| No `any` casts | ⚠️ | `json.ts` uses `as Prisma.InputJsonValue` — justified for Prisma JSON boundary |
| `leads.ts` service: `as Prisma.InputJsonValue` | ⚠️ | L69 — cast after `toPrismaJson()` which already returns the type. Redundant cast |
| No floating promises | ✅ | All `void` prefixed where intentional (`void startServer()`, `void run()`) |
| Validate untrusted input at boundaries | ✅ | Zod in schemas, `.parse()` in routes |
| Deterministic / ESM-consistent | ✅ | `"type": "module"`, `.js` extensions on all imports |
| Makefile orchestration preferred | ✅ | Makefile has `dev`, `check`, `migrate`, `ci`, `test` |

---

## Bugs

### B1: `deleteLeadByEmail` does not cascade-delete related records in application code

`leads.ts` `deleteLeadByEmail` calls `tx.lead.delete({ where: { id: lead.id } })`. This _does_ cascade at the DB level (Prisma schema has `onDelete: Cascade` on `lead_identities`, `consent_events`). However `form_submissions` uses `onDelete: SetNull` — so form submission rows become orphans with `lead_id = null`. This may be intentional for audit trail, but is not documented. If PIPEDA erasure requires full deletion of all lead-associated data, the orphaned form submissions still contain the `payload` JSONB (which may hold PII).

**Recommendation**: Either cascade-delete `form_submissions` too, or explicitly scrub `payload` to `null` during delete.

### B2: `toConsentStatus` unreachable default return

`consent.ts` `toConsentStatus` has an exhaustive `switch` on the 4 enum values, then falls through to `return ConsentStatus.pending`. TypeScript's exhaustive check should make this unreachable, but the guard `if (!value)` above means `undefined` is already handled. The trailing return is dead code — harmless but misleading.

### B3: Race condition on `lead.upsert` + `applyConsentStatus`

In `captureLead`, the lead is upserted and then `applyConsentStatus` re-reads `lead.consentStatus` from the DB. Between the upsert and the consent read, a concurrent transaction could change `consentStatus`. The transaction isolation level (Postgres default: `READ COMMITTED`) allows this. Low risk at launch traffic volumes, but could produce duplicate or skipped consent events under burst.

**Recommendation**: Use the `lead` returned by the upsert directly rather than re-reading in `applyConsentStatus`.

---

## Antipatterns

### A1: Duplicated Zod error handling in every route handler

All three routes (`events.ts`, `leads.ts` ×3) have identical `catch (error) { if (error instanceof ZodError) { ... } }` blocks. This should be a Fastify error handler or a shared utility.

```typescript
// suggestion: app-level Zod error handler in app.ts
app.setErrorHandler((error, request, reply) => {
  if (error instanceof ZodError) {
    return reply.code(400).send({
      ok: false,
      error: "invalid_request",
      issues: error.issues.map((i) => ({ path: i.path.join("."), message: i.message })),
    });
  }
  request.log.error({ err: error }, "unhandled request error");
  return reply.code(500).send({ ok: false, error: "internal_error" });
});
```

Then route handlers just `throw` or let Zod `.parse()` throw naturally.

### A2: Duplicated UTM schema definition

`schemas/events.ts` and `schemas/leads.ts` both define an identical `utmSchema`. Extract to a shared schema module (`schemas/shared.ts` or `schemas/utm.ts`).

### A3: `hashValue` creates a new HMAC instance per call

`request-context.ts` `hashValue` calls `createHmac("sha256", env.IP_HASH_PEPPER)` on every request for both IP and UA. The pepper never changes at runtime. While Node's `createHmac` is fast, creating an HMAC object per hash is unnecessary overhead. Consider caching the key material or using a helper that avoids re-parsing the key.

**Note**: This is minor at current traffic expectations.

### A4: No CORS configuration

The backend receives cross-origin requests from `frontend/dist/` (different host). No `@fastify/cors` plugin is registered. Browser `POST`s from frontend JS (`fetch`, `sendBeacon`) will be blocked by same-origin policy. `sendBeacon` sends simple requests (no preflight) but `fetch` with JSON content-type requires CORS headers.

**Recommendation**: Add `@fastify/cors` with an allowlist for the frontend origin(s).

### A5: `POST /v1/leads/delete` has no auth/access control

The PIPEDA delete-by-email endpoint is public with only rate limiting (10/min). Any caller can delete any lead by email. The roadmap says "admin auth or private network only" for sensitive endpoints (§7 mentions this for `/v1/metrics/summary`). Delete should have equivalent protection.

---

## Implementation Gaps

### G1: No `@fastify/cors` plugin

See A4 above. Frontend JS cannot reach these endpoints without CORS headers.

### G2: No form POST fallback handling (HTML form action)

The roadmap §4 and service rules require "form submission must degrade gracefully if JS is unavailable." The current `/v1/leads/capture` accepts JSON (via Zod schema) and `@fastify/formbody` is registered, but the Zod schema doesn't distinguish between the two. Test whether `application/x-www-form-urlencoded` bodies parse correctly through the current Zod schema (nested `utm` object may not survive form encoding).

Also, a no-JS form POST needs a redirect response (3xx), not a JSON body. The handler always returns JSON.

### G3: Session `endedAt` never set on inactivity timeout

`visitors.ts` sets `endedAt = occurredAt` on every session update. This means `endedAt` always equals the last event time, which is correct for "last activity" but provides no clean session-close signal. When a new session starts because inactivity threshold was exceeded, the _previous_ session's `endedAt` is not updated retroactively.

Not a bug — but queries expecting `endedAt` to mark session close accurately will get stale values for sessions that timed out silently.

### G4: Purge script does not clean orphaned sessions or visitors

`purge-retention.ts` deletes events older than 90 days but leaves their `sessions` and `visitors` rows intact. Over time, visitors with no remaining events accumulate. Consider a follow-up pass that removes sessions with no events and visitors with no sessions.

### G5: No idempotency on event ingestion

The task lists this as a stretch goal. Currently, rapid retries of the same beacon will create duplicate event rows. Not blocking for launch but worth tracking.

### G6: Missing `Dockerfile`

The roadmap §10 deployment steps reference `fly launch` generating a Dockerfile. No Dockerfile exists in `backend/`. This is expected to be generated at deploy time, but having a committed Dockerfile ensures reproducible builds and avoids `fly launch` interactive prompts in CI.

### G7: Missing `README.md` privacy contact

The compliance checklist requires "Document privacy contact in project README." `PRIVACY_CONTACT_EMAIL` is in env config but no `backend/README.md` was found.

---

## Efficiency Improvements

### E1: Batch heuristic link creation

`identity.ts` `linkHeuristicVisitors` issues one `linkLeadToVisitor` call (up to 2 DB round-trips each) per candidate in a serial `for` loop inside a transaction. With 20 candidates, that's up to 40 sequential queries. Use `Promise.all` or `createMany` to batch.

### E2: Reduce round-trips in `captureLead`

`captureLead` issues: upsert visitor, find latest session, create/update session, upsert lead, create event, link lead, heuristic links (N), create form submission, read lead for consent, update lead consent, create consent event — minimum 10+ round-trips in one transaction. Consider:
- Passing the `lead.consentStatus` from the upsert result instead of re-reading (also fixes B3).
- Batching the event + form submission creates via `$transaction` with multiple creates (they're already in one, but could be a `createMany` or parallel promises).

### E3: `toPrismaJson` double-serializes

`json.ts` does `JSON.parse(JSON.stringify(value))`. If `value` is already a plain object (which Zod-validated data always is), this is unnecessary overhead. It's a safety measure against class instances and getters, but a simpler `structuredClone(value)` would achieve the same without the serialize/deserialize cost, or skip the clone entirely for Zod-validated data.

---

## Summary

The implementation is solid and covers the full Phase 0-1 task spec. The main items needing attention before deploy are:

1. **CORS** (G1) — blocking, frontend JS can't reach the API without it.
2. **Delete endpoint auth** (A5) — public delete-by-email is a security issue.
3. **Form POST fallback** (G2) — roadmap requires no-JS form submission.
4. **Form submission PII on delete** (B1) — potential PIPEDA gap.
5. **Duplicated error handling / schemas** (A1, A2) — cleanup before the codebase grows.
